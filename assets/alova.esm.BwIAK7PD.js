const t="undefined",e=Promise,s=t=>e.resolve(t),a=t=>e.reject(t),o=Object,n=RegExp,r=void 0,c=null,i=!0,l=!1,h=(t,e,s)=>t.then(e,s),u=(t,e)=>t.finally(e),d=(t,e,s)=>JSON.stringify(t,e,s),p=(t,e=0)=>setTimeout(t,e),m=t=>clearTimeout(t),f=t=>o.keys(t),y=t=>o.values(t),g=(t,e)=>t.forEach(e),w=(t,...e)=>t.push(...e),v=(t,e)=>t.map(e),C=(t,e)=>t.filter(e),b=t=>t.length,$=t=>Array.isArray(t),k=(t,e)=>delete t[e],S=t=>typeof t,x=(t,e)=>t.includes(e),D=typeof window===t&&(typeof process!==t?!process.browser:typeof Deno!==t),E="memory",T="restore",O=()=>{},R=t=>t,U=t=>"function"===S(t),H=t=>"number"===S(t)&&!Number.isNaN(t),P=t=>"string"===S(t),j=t=>o.prototype.toString.call(t),N=t=>"[object Object]"===j(t),A=(t,e)=>t instanceof e,q=t=>t?t.getTime():Date.now(),F=t=>t.context,L=t=>t.config,I=t=>t.options,M=t=>t.key,B=(t,e,s=[])=>{const a=U(t)?t(...s):t;return e(!!a.key,"hook handler must be a method instance or a function that returns method instance"),a},J=t=>{const e=j(t);return/^\[object (Blob|FormData|ReadableStream|URLSearchParams)\]$/i.test(e)||A(t,ArrayBuffer)},_=(t,...e)=>o.assign(t,...e),G=(t,...e)=>{const s={};for(const a in t)e.includes(a)||(s[a]=t[a]);return s};function K(){let t,e;return{promise:new Promise((s,a)=>{t=s,e=a}),resolve:t,reject:e}}const W=t=>{const{cacheFor:e}=L(t);let s=E,a=()=>0,o=l,n=r;const c=U(e);if(!c){let c=e;if(N(e)){const{mode:t=E,expire:a,tag:i}=e||{};s=t,o=t===T,n=i?i.toString():r,c=a}a=e=>{return s=U(c)?c({method:t,mode:e}):c,H(s)?q()+s:q(s||r);var s}}return{f:e,c:c,e:a,m:s,s:o,t:n}},z=(t,...e)=>new t(...e),Q=(t,e=[])=>U(t)?t(...e):t,V=(t=0)=>{let e=r;return s=>{e&&clearTimeout(e),e=p(s,t)}},X=(t,e)=>"$a."+t+e,Y=(t,e,s)=>{const a=/^https?:\/\//i.test(e);a||(t=t.endsWith("/")?t.slice(0,-1):t,""!==e&&(e=e.startsWith("/")?e:`/${e}`));const o=a?e:t+e,n=P(s)?s:v(C(f(s),t=>s[t]!==r),t=>`${t}=${s[t]}`).join("&");return n?+o.includes("?")?`${o}&${n}`:`${o}?${n}`:o},Z=t=>{if($(t))return v(t,Z);if(N(t)&&t.constructor===o){const e={};return g(f(t),s=>{e[s]=Z(t[s])}),e}return t};class tt extends Error{constructor(t,e,s){super(e+(s?`\n\nFor detailed: https://alova.js.org/error#${s}`:"")),this.name=`[alova${t?`/${t}`:""}]`}}const et=(t="")=>(e,s,a)=>{if(!e)throw z(tt,t,s,a)},st=JSON.parse,at=()=>st.bridgeData||{},ot=()=>{const t={};return{eventMap:t,on(e,s){const a=t[e]=t[e]||[];return w(a,s),()=>{t[e]=C(a,t=>t!==s)}},off(e,s){const a=t[e];if(a)if(s){const t=a.indexOf(s);t>-1&&a.splice(t,1)}else delete t[e]},emit(e,s){const a=t[e]||[];return v(a,t=>t(s))}}};class nt{constructor(t,e,s,a){this.s=t,this.k=e,this.$dhy=s,this.$exp=a}get v(){return this.$dhy(this.s)}get e(){return this.$exp(this.s)}}class rt extends nt{constructor(t,e,s,a,o){super(t,e,s,a),this.$upd=o}set v(t){this.$upd(this.s,t)}get v(){return this.$dhy(this.s)}}let ct={autoHitCache:"global",ssr:D};const it="color: black; font-size: 12px; font-weight: bolder";var lt=(t,e,s,a)=>{const o=console,n=(...t)=>console.log(...t),{url:r}=e,c=s===T,i="[42m%s[49m",l="[32m%s[39m",h=` [HitCache]${r} `,u=()=>Array(b(h)+1).join("^");ct.ssr?(n(i,h),n(l," Cache ",t),n(l," Mode  ",s),c&&n(l," Tag   ",a),n(l,u())):(o.groupCollapsed?o.groupCollapsed("%cHitCache","padding: 2px 6px; background: #c4fcd3; color: #53b56d;",r):n(i,h),n("%c[Cache]",it,t),n("%c[Mode]",it,s),c&&n("%c[Tag]",it,a),n("%c[Method]",it,e),o.groupEnd?o.groupEnd():n(l,u()))};const ht=t=>`hss.${t}`,ut="hsr.",dt=t=>ut+t,pt="$$hsrs",mt="__$<>$__",ft=(t,e)=>{t[e]=0},yt=async(t,s,a,o,c,i,l)=>{if(o>q()&&a){const h=X(t,s);if(await c.set(h,C([a,o===1/0?r:o,l],Boolean)),i){const t={},s=[];g(i,e=>{const a=A(e,n),o=a?e.source+(e.flags?mt+e.flags:""):e;o&&(a&&!t[o]&&w(s,o),ft(t,a?dt(o):ht(o)))});const a=v(f(t),async t=>{const e=await c.get(t)||{};ft(e,h),await c.set(t,e)}),o=async()=>{if(b(s)){const t=await c.get(pt)||[];w(t,...s),await c.set(pt,t)}};await e.all([...a,o()])}}},gt=async(t,e,s,a)=>{const o=await s.get(X(t,e));if(o){const[n,r,c]=o;if(c===a&&(!r||r>q()))return o;await(async(t,e,s)=>{const a=X(t,e);await s.remove(a)})(t,e,s)}},wt=async(t,e,s,a)=>{const o=await gt(t,e,s,a);return o?o[0]:r};const vt=async(t,{policy:e="all"}={})=>{if(t&&t.key){const{id:s,l1Cache:a,l2Cache:o}=F(t),n=M(t),{f:c,c:i,s:l,e:h,t:u}=W(t);if(i)return c();let d="l2"!==e?await wt(s,n,a):r;return"l2"===e?d=await wt(s,n,o,u):"all"!==e||d||l&&h(T)>q()&&(d=await wt(s,n,o,u)),d}},Ct=async t=>{const{autoHitCache:s}=ct,{l1Cache:a,l2Cache:o}=F(t),r=M(t),{name:c}=L(t),i={global:[...Nt,...At],self:[a,o],close:[]}[s];i&&b(i)&&await e.all(v(i,t=>(async(t,s,a)=>{const o=`${s}`,r={},c=ht(t);let i;if(r[c]=await a.get(c),s){const t=ht(o);r[t]=await a.get(t),i=await a.get(pt);const s=[];i&&b(i)&&(g(i,t=>{const[e,a]=t.split(mt);z(n,e,a).test(o)&&w(s,t)}),await e.all(v(s,async t=>{const e=dt(t);r[e]=await a.get(e)})))}const l=async t=>{try{await a.remove(t);for(const e in r){const s=r[e];s&&k(s,t)}}catch(e){}},h={};await e.all(v(f(r),async t=>{const s=r[t];if(s){const t=[];for(const e in s)h[e]||(ft(h,e),w(t,l(e)));await e.all(t)}}));const u=b(i||[]);await e.all(v(f(r),async t=>{const e=r[t];e&&(b(f(e))?await a.set(t,e):(await a.remove(t),t.includes(ut)&&i&&(i=C(i,e=>dt(e)!==t))))})),u!==b(i||[])&&await a.set(pt,i)})(r,c,t)))},bt={};function $t(t,s){let o,n=i;const d=z(e,t=>{o=t});return{abort:()=>{h(d,t=>t&&t.abort())},onDownload:t=>{h(d,e=>e&&e.onDownload&&e.onDownload(t))},onUpload:t=>{h(d,e=>e&&e.onUpload&&e.onUpload(t))},response:async()=>{const{beforeRequest:d=O,responded:p,requestAdapter:m,cacheLogger:f}=(t=>I(F(t)))(t),y=M(t),{s:g,t:w,m:v,e:C}=W(t),{id:b,l1Cache:$,l2Cache:S,snapshots:x}=F(t),{cacheFor:D}=L(t),{hitSource:H}=t;let j=await(U(D)?D():s?r:wt(b,y,$));if(v===T&&!j&&!s){const t=await gt(b,y,S,w);if(t){const[e,s]=t;await yt(b,y,e,s,$,H),j=e}}const A=(t=>{const{data:e,config:s}=t,a={...s},{headers:o={},params:n={}}=a,r=F(t);a.headers={...o},a.params=P(n)?n:{...n};const c=z(St,t.type,r,t.url,a,e);return _(c,{...t,config:a})})(t);await d(A);const{baseURL:q,url:B,type:G,data:K}=A,{params:Q={},headers:V={},transform:X=R,shareRequest:tt}=L(A),et=bt[b]=bt[b]||{},st=A.data,at=J(st);let ot=at?r:et[y],nt=R,rt=r,ct=O;if(U(p))nt=p;else if(N(p)){const{onSuccess:t,onError:e,onComplete:s}=p;nt=U(t)?t:nt,rt=U(e)?e:rt,ct=U(s)?s:ct}if(j!==r)return o(),A.fromCache=i,(ht=lt,U(it=f)?it:[l,c].includes(it)?O:ht)(j,A,v,w),ct(A),j;var it,ht;if(n=l,!tt||!ot){const t=m({url:Y(q,B,Q),type:G,data:K,headers:V},A);ot=et[y]=t}o(ot);const ut=async(s,a,o=true)=>{const n=await s,r=await X(n,a||{});x.save(t);try{await Ct(A)}catch(c){}if((!st||!at)&&o)try{await e.all([yt(b,y,r,C(E),$,H),g&&yt(b,y,r,C(T),S,H,w)])}catch(i){}return Z(r)};return u(h(e.all([ot.response(),ot.headers()]),([t,e])=>(k(et,y),ut(nt(t,A),e)),t=>(k(et,y),U(rt)?ut(rt(t,A),r,l):a(t))),()=>{ct(A)})},fromCache:()=>n}}const kt=(t,e)=>()=>{const s=e.indexOf(t);s>=0&&e.splice(s,1)};class St{constructor(t,e,s,a,o){this.dhs=[],this.uhs=[],this.fromCache=r;const n=()=>{n.a()};n.a=O,t=t.toUpperCase();const c=this,i=I(e);c.abort=n,c.baseURL=i.baseURL||"",c.url=s,c.type=t,c.context=e;const l={},h="cacheFor",u=N(i[h])?i[h][t]:r,d=a&&a.hitSource;g(["timeout","shareRequest"],t=>{i[t]!==r&&(l[t]=i[t])}),u!==r&&(l[h]=u),d&&(c.hitSource=v($(d)?d:[d],t=>A(t,St)?M(t):t),k(a,"hitSource")),c.config={...l,headers:{},params:{},...a||{}},c.data=o,c.meta=a?a.meta:c.meta,c.key=c.generateKey()}onDownload(t){return w(this.dhs,t),kt(t,this.dhs)}onUpload(t){return w(this.uhs,t),kt(t,this.uhs)}send(t=l){const e=this,{response:s,onDownload:a,onUpload:o,abort:n,fromCache:c}=$t(e,t);return b(e.dhs)>0&&a((t,s)=>g(e.dhs,e=>e({loaded:t,total:s}))),b(e.uhs)>0&&o((t,s)=>g(e.uhs,e=>e({loaded:t,total:s}))),e.abort.a=n,e.fromCache=r,e.promise=h(s(),t=>(e.fromCache=c(),t)),e.promise}setName(t){L(this).name=t}generateKey(){return(t=>{const{params:e,headers:s}=L(t);return d([t.type,t.url,e,t.data,s])})(this)}then(t,e){return h(this.send(),t,e)}catch(t){return((t,e)=>t.catch(e))(this.send(),t)}finally(t){return u(this.send(),t)}}const xt=et(),Dt="success",Et=()=>{const t=ot(),e=localStorage;return{set:(s,a)=>{e.setItem(s,d(a)),t.emit(Dt,{type:"set",key:s,value:a,container:e})},get:s=>{const a=e.getItem(s),o=a?(t=>JSON.parse(t))(a):a;return t.emit(Dt,{type:"get",key:s,value:o,container:e}),o},remove:s=>{e.removeItem(s),t.emit(Dt,{type:"remove",key:s,container:e})},clear:()=>{e.clear(),t.emit(Dt,{type:"clear",key:"",container:e})},emitter:t}},Tt=Set;class Ot{constructor(t){this.records={},this.occupy=0,xt(t>=0,"expected snapshots limit to be >= 0"),this.capacity=t}save(t){const{name:e}=L(t),{records:s,occupy:a,capacity:o}=this;if(e&&a<o){(s[e]=s[e]||z(Tt)).add(t),this.occupy+=1}}match(t,e=!0){let s,a,o,r=t;N(t)&&(r=t.name,o=t.filter),A(r,n)?a=r:P(r)&&(s=r);const{records:c}=this;let i=z(Tt);s?i=c[s]||i:a&&g(C(f(c),t=>a.test(t)),t=>{c[t].forEach(t=>i.add(t))});const l=U(o)?C([...i],o):[...i];return e?l:l[0]}}const Rt="GET",Ut={cacheFor:{[Rt]:3e5},shareRequest:i,snapshots:1e3};let Ht=0;class Pt{constructor(t){var e,s;const a=this;a.id=(t.id||(Ht+=1)).toString(),a.l1Cache=t.l1Cache||(()=>{let t={};const e=ot();return{set(s,a){t[s]=a,e.emit(Dt,{type:"set",key:s,value:a,container:t})},get:s=>{const a=t[s];return e.emit(Dt,{type:"get",key:s,value:a,container:t}),a},remove(s){k(t,s),e.emit(Dt,{type:"remove",key:s,container:t})},clear:()=>{t={},e.emit(Dt,{type:"clear",key:"",container:t})},emitter:e}})(),a.l2Cache=t.l2Cache||("undefined"!=typeof localStorage?Et():(()=>{const t=()=>{xt(l,"l2Cache is not defined.")};return{set:()=>{t()},get:()=>(t(),r),remove:()=>{t()},clear:()=>{}}})()),a.options={...Ut,...t},a.snapshots=z(Ot,null!==(s=null!==(e=t.snapshots)&&void 0!==e?e:Ut.snapshots)&&void 0!==s?s:0)}Request(t){return z(St,t.method||Rt,this,t.url,t,t.data)}Get(t,e){return z(St,Rt,this,t,e)}Post(t,e,s){return z(St,"POST",this,t,s,e)}Delete(t,e,s){return z(St,"DELETE",this,t,s,e)}Put(t,e,s){return z(St,"PUT",this,t,s,e)}Head(t,e){return z(St,"HEAD",this,t,e)}Patch(t,e,s){return z(St,"PATCH",this,t,s,e)}Options(t,e){return z(St,"OPTIONS",this,t,e)}}let jt=r;const Nt=[],At=[],qt=t=>{const e=z(Pt,t),s=e.options.statesHook;jt&&s&&xt(jt.name===s.name,"expected to use the same `statesHook`"),jt=s;const{l1Cache:a,l2Cache:o}=e;return!Nt.includes(a)&&w(Nt,a),!At.includes(o)&&w(At,o),e},Ft=()=>(xt(jt,"`statesHook` is not set in alova instance"),jt);export{R as $,Q as A,at as B,Ft as C,ot as D,V as E,y as F,h as G,rt as H,x as I,w as J,v as K,nt as L,St as M,ct as N,vt as O,e as P,G as Q,f as R,m as S,k as T,c as U,o as V,$ as W,l as a,U as b,K as c,P as d,z as e,g as f,H as g,a as h,N as i,j,J as k,b as l,qt as m,O as n,_ as o,s as p,B as q,et as r,p as s,i as t,r as u,F as v,X as w,M as x,A as y,q as z};
